~~# Updated Critique of Point and Track

This is an update to [this ADR](./pointInterfaceCritique.md) where the TL;DR is:
> The Point and Track interfaces have design flaws (from pre-ARIA days) that should only be fixed when the effort can be
> justified.

## TL;DR

- The justification for a significant overhaul to Point and Track is here. Supporting new data formats is important
  enough to warrant a large effort

- Consequently, we need to be more specific about flaws and potential solutions

## Design Flaw 1:  `Point` was designed to mimic ONE data format

- In pre-ARIA legacy code the `Point` interface was built to Mimic exactly one format, with all its quirks,
- The original design was not intended to support other formats.
- Nor, was there a plan or strategy to support alternative data formats.
- Thus, the `Point` interface got implemented by many different classes that each decorated the interface with
  a different set of additional methods (depending on the _new_ data format). The additional methods
  split into two main groups, physical related (e.g. `climbRate()`, `acceleration()`) and metadata related (
  e.g. `wakeCategory()` or `aircraftType()`)

## Design Flaw 2: Poor separation btw _"Raw Data"_ and its _"Smoothed View"_

- Raw location data is imprecise. Location data has noise that needs to be corrected.
- In pre-ARIA legacy code `Point` and `Track` implementations were mutable objects that were **corrected in place**.
- This led to imperfect separation between the _"raw location data"_, the _"smoothed view of the raw data"_, and the _"
  track smoothers that manipulated the location data"_
- These intertwining concerns are very reminiscent of a GUI interface design that does not use an MVC pattern
    - Model = Raw Data
    - View = Smoothed View of Data
    - Controller = Track Smoothing Functions
- A better design make it easier to simultaneously support "leaving the raw location data alone" and "getting a
  corrected view of the raw location data"

## Design Flaw 3: Tracks are not generic
- `Track` objects are awkward to work this because the "type of point metadata" is not easily accessible.
-  In other words, `Track` should be a generic class.  But, this doesn't work out correctly because the underlying Points aren't generic.

## Design Flaw 4: Track Smoothers have unnatural access to Fields from Raw data

- Some location data formats contain fields that can help produce well-smoothed data.
    - For example, NOP data has a field that tells you if a radar hit was _sensed by radar equipment_ or if it was
      _synthetically generated by software_. These synthetic radar hit are inaccurate and need to be removed.
- Accessing these fields is unnatural given the existing Point interface which does not have a way to "tunnel into" the
  raw data.

---

### A Better Approach for `Point`

- If we started again today we would likely replace the Point interface with a record. Something like:
    - `public record Point<T>(Position position, T rawData)`
    - or
    - `public record SmoothedPoint<T>(KineticPosition position, T rawData)`
- This approach is appealing because "format specific data" can be directly accessed via the "rawData" field. There is
  no need to create N different classes that implement the `Point` interface.
- In other words, this approach benefits greatly from simple, easy-to-understand classes and records that merely
  repackage a data format
  like `AsdexHitData`, `NopRhMessageData`, `AsterixHit`, or `AdsbHit`
  etc.

### A Better Approach for `Track`

- Another alternative is to build an even stronger firewall between the "raw data" and the "travel path" of the aircraft
- Something like:
    - `public record Track<T>(TreeSet<Position> positions, List<T> rawData)`
- The upside of this approach is that it strongly separates the `positions` from the `rawData`.
    - This makes it more natural to smooth (i.e., correct) the position data without touching the raw input data.
    - It also makes it more natural to generate interpolated positions with timestamps that do not match the
      timestamps from the raw data.
- The downside of this approach is that "drilling down" to the piece of rawData that was current at time T (and its
  format specific fields) will require an extra step.


